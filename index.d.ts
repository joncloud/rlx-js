export type NoneOption<T> = {
  isSome(): false;
  isNone(): true;
  expect(msg: string): never;
  unwrap(): never;
  unwrapOr(def: T): T;
  unwrapOrElse(fn: () => T): T;
  map<U>(fn: (val: T) => U): NoneOption<U>;
  mapOr<U>(def: U, fn: (val: T) => U): NoneOption<U>;
  mapOrElse<U>(def: () => U, fn: (val: T) => U): NoneOption<U>;
  okOr<E>(error: Promise<E>): PromiseResult<T, E>;
  okOr<E>(error: E): ErrResult<T, E>;
  okOrElse<E>(fn: () => Promise<E>): PromiseResult<T, E>;
  okOrElse<E>(fn: () => E): ErrResult<T, E>;
  iter(): Iterable<T>;
  and(optionB: Promise<Option<T>>): NoneOption<T>;
  and(optionB: PromiseOption<T>): NoneOption<T>;
  and(optionB: SomeOption<T>): NoneOption<T>;
  and(optionB: NoneOption<T>): NoneOption<T>;
  and(optionB: Option<T>): NoneOption<T>;
  andThen(fn: (val: T) => Promise<Option<T>>): NoneOption<T>;
  andThen(fn: (val: T) => PromiseOption<T>): NoneOption<T>;
  andThen(fn: (val: T) => SomeOption<T>): NoneOption<T>;
  andThen(fn: (val: T) => NoneOption<T>): NoneOption<T>;
  andThen(fn: (val: T) => Option<T>): NoneOption<T>;
  or(optionB: Promise<Option<T>>): PromiseOption<T>;
  or(optionB: PromiseOption<T>): PromiseOption<T>;
  or(optionB: SomeOption<T>): SomeOption<T>;
  or(optionB: NoneOption<T>): NoneOption<T>;
  or(optionB: Option<T>): Option<T>;
  orElse(fn: () => Promise<Option<T>>): PromiseOption<T>;
  orElse(fn: () => PromiseOption<T>): PromiseOption<T>;
  orElse(fn: () => SomeOption<T>): SomeOption<T>;
  orElse(fn: () => NoneOption<T>): NoneOption<T>;
  orElse(fn: () => Option<T>): Option<T>;
  valueOf(): 'none{}';
};

export function None<T>(): NoneOption<T>;

export type SomeOption<T> = {
  isSome(): true;
  isNone(): false;
  expect(msg: string): T;
  unwrap(): T;
  unwrapOr(def: T): T;
  unwrapOrElse(fn: () => T): T;
  map<U>(fn: (val: T) => Promise<U>): PromiseOption<U>;
  map<U>(fn: (val: T) => U): SomeOption<U>;
  mapOr<U>(def: Promise<U>, fn: (val: T) => Promise<U>): PromiseOption<U>;
  mapOr<U>(def: U, fn: (val: T) => U): SomeOption<U>;
  mapOrElse<U>(def: () => Promise<U>, fn: (val: T) => U): PromiseOption<U>;
  mapOrElse<U>(def: () => U, fn: (val: T) => U): SomeOption<U>;
  okOr<E>(error: Promise<E>): OkResult<T, E>;
  okOr<E>(error: E): OkResult<T, E>;
  okOrElse<E>(fn: () => Promise<E>): OkResult<T, E>;
  okOrElse<E>(fn: () => E): OkResult<T, E>;
  iter(): Iterable<T>;
  and(optionB: Promise<Option<T>>): PromiseOption<T>;
  and(optionB: PromiseOption<T>): PromiseOption<T>;
  and(optionB: SomeOption<T>): SomeOption<T>;
  and(optionB: NoneOption<T>): NoneOption<T>;
  and(optionB: Option<T>): Option<T>;
  andThen(fn: (val: T) => Promise<Option<T>>): PromiseOption<T>;
  andThen(fn: (val: T) => PromiseOption<T>): PromiseOption<T>;
  andThen(fn: (val: T) => SomeOption<T>): SomeOption<T>;
  andThen(fn: (val: T) => NoneOption<T>): NoneOption<T>;
  andThen(fn: (val: T) => Option<T>): Option<T>;
  or(optionB: Promise<Option<T>>): SomeOption<T>;
  or(optionB: PromiseOption<T>): SomeOption<T>;
  or(optionB: SomeOption<T>): SomeOption<T>;
  or(optionB: NoneOption<T>): SomeOption<T>;
  or(optionB: Option<T>): SomeOption<T>;
  orElse(fn: () => Promise<Option<T>>): SomeOption<T>;
  orElse(fn: () => PromiseOption<T>): SomeOption<T>;
  orElse(fn: () => SomeOption<T>): SomeOption<T>;
  orElse(fn: () => NoneOption<T>): SomeOption<T>;
  orElse(fn: () => Option<T>): SomeOption<T>;
  valueOf(): string;
};

export function Some<T>(value: T): SomeOption<T>;
export function Some<T>(value: Promise<T>): PromiseOption<T>;

export type Option<T> = NoneOption<T> | SomeOption<T>;

export type PromiseOption<T> = {
  expect(msg: string): Promise<T>;
  unwrap(): Promise<T>;
  unwrapOr(def: T): Promise<T>;
  unwrapOrElse(fn: () => T): Promise<T>;
  map<E>(fn: (val: T) => Promise<E>): PromiseOption<E>;
  map<E>(fn: (val: T) => E): PromiseOption<E>;
  mapOr<E>(def: E, fn: (val: T) => E): PromiseOption<E>;
  mapOrElse<E>(def: () => E, fn: (val: T) => E): PromiseOption<E>;
  okOr<E>(error: E): PromiseResult<T, E>;
  okOrElse<E>(fn: () => E): PromiseResult<T, E>;
  iter(): AsyncIterable<T>;
  and(optionB: Promise<Option<T>>): PromiseOption<T>;
  and(optionB: PromiseOption<T>): PromiseOption<T>;
  and(optionB: SomeOption<T>): PromiseOption<T>;
  and(optionB: NoneOption<T>): PromiseOption<T>;
  and(optionB: Option<T>): PromiseOption<T>;
  andThen(fn: (val: T) => Promise<Option<T>>): PromiseOption<T>;
  andThen(fn: (val: T) => PromiseOption<T>): PromiseOption<T>;
  andThen(fn: (val: T) => SomeOption<T>): PromiseOption<T>;
  andThen(fn: (val: T) => NoneOption<T>): PromiseOption<T>;
  andThen(fn: (val: T) => Option<T>): PromiseOption<T>;
  or(optionB: Promise<Option<T>>): PromiseOption<T>;
  or(optionB: PromiseOption<T>): PromiseOption<T>;
  or(optionB: SomeOption<T>): PromiseOption<T>;
  or(optionB: NoneOption<T>): PromiseOption<T>;
  or(optionB: Option<T>): PromiseOption<T>;
  orElse(fn: () => Promise<Option<T>>): PromiseOption<T>;
  orElse(fn: () => PromiseOption<T>): PromiseOption<T>;
  orElse(fn: () => SomeOption<T>): PromiseOption<T>;
  orElse(fn: () => NoneOption<T>): PromiseOption<T>;
  orElse(fn: () => Option<T>): PromiseOption<T>;
} & PromiseLike<Option<T>>;

export function ToOption<T>(value: null): NoneOption<T>;
export function ToOption<T>(value: undefined): NoneOption<T>;
export function ToOption<T>(value: Promise<SomeOption<T>>): PromiseOption<T>;
export function ToOption<T>(value: Promise<NoneOption<T>>): PromiseOption<T>;
export function ToOption<T>(value: Promise<Option<T>>): PromiseOption<T>;
export function ToOption<T>(value: SomeOption<T>): SomeOption<T>;
export function ToOption<T>(value: NoneOption<T>): NoneOption<T>;
export function ToOption<T>(value: Option<T>): Option<T>;
export function ToOption<T>(value: T): SomeOption<T>;

export type OkResult<T, E = never> = {
  isOk(): true;
  isErr(): false;
  ok(): SomeOption<T>;
  err(): NoneOption<E>;
  map<U>(fn: (val: T) => Promise<U>): PromiseResult<U, E>;
  map<U>(fn: (val: T) => U): OkResult<U, E>;
  mapErr<F>(fn: (err: E) => Promise<F>): OkResult<T, F>;
  mapErr<F>(fn: (err: E) => F): OkResult<T, F>;
  iter(): Iterable<T>;
  and(res: Promise<Result<T, E>>): PromiseResult<T, E>;
  and(res: PromiseResult<T, E>): PromiseResult<T, E>;
  and(res: OkResult<T, E>): OkResult<T, E>;
  and(res: ErrResult<T, E>): ErrResult<T, E>;
  and(res: Result<T, E>): Result<T, E>;
  andThen(fn: (val: T) => Promise<Result<T, E>>): PromiseResult<T, E>;
  andThen(fn: (val: T) => PromiseResult<T, E>): PromiseResult<T, E>;
  andThen(fn: (val: T) => OkResult<T, E>): OkResult<T, E>;
  andThen(fn: (val: T) => ErrResult<T, E>): ErrResult<T, E>;
  andThen(fn: (val: T) => Result<T, E>): Result<T, E>;
  or(res: Promise<Result<T, E>>): OkResult<T, E>;
  or(res: PromiseResult<T, E>): OkResult<T, E>;
  or(res: OkResult<T, E>): OkResult<T, E>;
  or(res: ErrResult<T, E>): OkResult<T, E>;
  or(res: Result<T, E>): OkResult<T, E>;
  orElse(fn: (err: E) => Promise<Result<T, E>>): OkResult<T, E>;
  orElse(fn: (err: E) => PromiseResult<T, E>): OkResult<T, E>;
  orElse(fn: (err: E) => OkResult<T, E>): OkResult<T, E>;
  orElse(fn: (err: E) => ErrResult<T, E>): OkResult<T, E>;
  orElse(fn: (err: E) => Result<T, E>): OkResult<T, E>;
  unwrap(): T;
  unwrapErr(): never;
  unwrapOr(optionB: T): T;
  unwrapOrElse(fn: (err: E) => Promise<T>): T;
  unwrapOrElse(fn: (err: E) => T): T;
  expect(msg: string): T;
  expectErr(msg: string): never;
  valueOf(): string;
};

export type ErrResult<T, E> = {
  isOk(): false;
  isErr(): true;
  ok(): NoneOption<T>;
  err(): SomeOption<E>;
  map<U>(fn: (val: T) => Promise<U>): ErrResult<U, E>;
  map<U>(fn: (val: T) => U): ErrResult<U, E>;
  mapErr<F>(fn: (err: E) => Promise<F>): PromiseResult<T, F>;
  mapErr<F>(fn: (err: E) => F): ErrResult<T, F>;
  iter(): Iterable<T>;
  and(res: Promise<Result<T, E>>): ErrResult<T, E>;
  and(res: PromiseResult<T, E>): ErrResult<T, E>;
  and(res: OkResult<T, E>): ErrResult<T, E>;
  and(res: ErrResult<T, E>): ErrResult<T, E>;
  and(res: Result<T, E>): ErrResult<T, E>;
  andThen(fn: (val: T) => Promise<Result<T, E>>): ErrResult<T, E>;
  andThen(fn: (val: T) => PromiseResult<T, E>): ErrResult<T, E>;
  andThen(fn: (val: T) => OkResult<T, E>): ErrResult<T, E>;
  andThen(fn: (val: T) => ErrResult<T, E>): ErrResult<T, E>;
  andThen(fn: (val: T) => Result<T, E>): ErrResult<T, E>;
  or(res: Promise<Result<T, E>>): PromiseResult<T, E>;
  or(res: PromiseResult<T, E>): PromiseResult<T, E>;
  or(res: OkResult<T, E>): OkResult<T, E>;
  or(res: ErrResult<T, E>): ErrResult<T, E>;
  or(res: Result<T, E>): Result<T, E>;
  orElse(fn: (err: E) => Promise<Result<T, E>>): PromiseResult<T, E>;
  orElse(fn: (err: E) => PromiseResult<T, E>): PromiseResult<T, E>;
  orElse(fn: (err: E) => OkResult<T, E>): OkResult<T, E>;
  orElse(fn: (err: E) => ErrResult<T, E>): ErrResult<T, E>;
  orElse(fn: (err: E) => Result<T, E>): Result<T, E>;
  unwrap(): never;
  unwrapErr(): E;
  unwrapOr(optionB: T): T;
  unwrapOrElse(fn: (err: E) => Promise<T>): Promise<T>;
  unwrapOrElse(fn: (err: E) => T): T;
  expect(msg: string): never;
  expectErr(msg: string): E;
  valueOf(): string;
};
export type Result<T, E> = OkResult<T, E> | ErrResult<T, E>;

export type PromiseResult<T, E> = {
  ok(): PromiseOption<T>;
  err(): PromiseOption<E>;
  map<U>(fn: (val: T) => Promise<U>): PromiseResult<U, E>;
  map<U>(fn: (val: T) => U): PromiseResult<U, E>;
  mapErr<F>(fn: (err: E) => Promise<F>): PromiseResult<T, F>;
  mapErr<F>(fn: (err: E) => F): PromiseResult<T, F>;
  iter(): AsyncIterable<T>;
  and(res: Promise<Result<T, E>>): PromiseResult<T, E>;
  and(res: PromiseResult<T, E>): PromiseResult<T, E>;
  and(res: Result<T, E>): PromiseResult<T, E>;
  andThen(fn: (val: T) => Promise<Result<T, E>>): ErrResult<T, E>;
  andThen(fn: (val: T) => PromiseResult<T, E>): ErrResult<T, E>;
  andThen(fn: (val: T) => Result<T, E>): ErrResult<T, E>;
  or(res: Promise<Result<T, E>>): PromiseResult<T, E>;
  or(res: PromiseResult<T, E>): PromiseResult<T, E>;
  or(res: Result<T, E>): PromiseResult<T, E>;
  orElse(fn: (err: E) => Promise<Result<T, E>>): PromiseResult<T, E>;
  orElse(fn: (err: E) => PromiseResult<T, E>): PromiseResult<T, E>;
  orElse(fn: (err: E) => Result<T, E>): PromiseResult<T, E>;
  unwrap(): Promise<T>;
  unwrapErr(): Promise<E>;
  unwrapOr(optionB: T): Promise<T>;
  unwrapOrElse(fn: (err: E) => Promise<T>): Promise<T>;
  unwrapOrElse(fn: (err: E) => T): Promise<T>;
  expect(msg: string): Promise<T>;
  expectErr(msg: string): Promise<E>;
} & PromiseLike<Result<T, E>>;

export function Ok<T, E = never>(value: Promise<T>): PromiseResult<T, E>;
export function Ok<T, E = never>(value: T): OkResult<T, E>;
export function Err<E, T = never>(error: Promise<E>): PromiseResult<T, E>;
export function Err<E, T = never>(error: E): ErrResult<T, E>;
