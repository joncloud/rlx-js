
export type Option<T> = {
  isSome(): boolean;
  isNone(): boolean;
  expect(msg: string): T | never;
  unwrap(): T | never;
  unwrapOr(def: T): T;
  unwrapOrElse(fn: () => T): T;
  map<U>(fn: (val: T) => Promise<U>): PromiseOption<U>;
  map<U>(fn: (val: T) => U): Option<U>;
  mapOr<U>(def: Promise<U>, fn: (val: T) => Promise<U>): PromiseOption<U>;
  mapOr<U>(def: U, fn: (val: T) => U): Option<U>;
  mapOrElse<U>(def: () => Promise<U>, fn: (val: T) => U): PromiseOption<U>;
  mapOrElse<U>(def: () => U, fn: (val: T) => U): Option<U>;
  okOr<E>(error: Promise<E>): PromiseResult<T, E>;
  okOr<E>(error: E): Result<T, E>;
  okOrElse<E>(fn: () => Promise<E>): PromiseResult<T, E>;
  okOrElse<E>(fn: () => E): Result<T, E>;
  iter(): Iterable<T>;
  and<U>(optionB: Promise<Option<U>>): PromiseOption<U>;
  and<U>(optionB: PromiseOption<U>): PromiseOption<U>;
  and<U>(optionB: Option<U>): Option<U>;
  andThen<U>(fn: (val: T) => Promise<Option<U>>): PromiseOption<U>;
  andThen<U>(fn: (val: T) => PromiseOption<U>): PromiseOption<U>;
  andThen<U>(fn: (val: T) => Option<U>): Option<U>;
  or(optionB: Promise<Option<T>>): PromiseOption<T>;
  or(optionB: PromiseOption<T>): PromiseOption<T>;
  or(optionB: Option<T>): Option<T>;
  orElse(fn: () => Promise<Option<T>>): PromiseOption<T>;
  orElse(fn: () => PromiseOption<T>): PromiseOption<T>;
  orElse(fn: () => Option<T>): Option<T>;
  match<U>(opts: { some: (val: T) => U, none: () => U }): U;
  valueOf(): string;
};

export type NoneOption<T> = {
  isSome(): false;
  isNone(): true;
  expect(msg: string): never;
  unwrap(): never;
  map<U>(fn: (val: T) => U): NoneOption<U>;
  mapOr<U>(def: U, fn: (val: T) => U): NoneOption<U>;
  mapOrElse<U>(def: () => U, fn: (val: T) => U): NoneOption<U>;
  okOr<E>(error: E): ErrResult<T, E>;
  okOrElse<E>(fn: () => E): ErrResult<T, E>;
  and<U>(optionB: Promise<Option<U>>): NoneOption<U>;
  and<U>(optionB: PromiseOption<U>): NoneOption<U>;
  and<U>(optionB: SomeOption<U>): NoneOption<U>;
  and<U>(optionB: NoneOption<U>): NoneOption<U>;
  and<U>(optionB: Option<U>): NoneOption<U>;
  andThen<U>(fn: (val: T) => Promise<Option<U>>): NoneOption<U>;
  andThen<U>(fn: (val: T) => PromiseOption<U>): NoneOption<U>;
  andThen<U>(fn: (val: T) => SomeOption<U>): NoneOption<U>;
  andThen<U>(fn: (val: T) => NoneOption<U>): NoneOption<U>;
  andThen<U>(fn: (val: T) => Option<U>): NoneOption<U>;
  or(optionB: SomeOption<T>): SomeOption<T>;
  or(optionB: NoneOption<T>): NoneOption<T>;
  orElse(fn: () => SomeOption<T>): SomeOption<T>;
  orElse(fn: () => NoneOption<T>): NoneOption<T>;
  valueOf(): 'none{}';
} & Option<T>;

export function None<T>(): NoneOption<T>;

export type SomeOption<T> = {
  isSome(): true;
  isNone(): false;
  expect(msg: string): T;
  unwrap(): T;
  map<U>(fn: (val: T) => U): SomeOption<U>;
  mapOr<U>(def: U, fn: (val: T) => U): SomeOption<U>;
  mapOrElse<U>(def: () => U, fn: (val: T) => U): SomeOption<U>;
  okOr<E>(error: E): OkResult<T, E>;
  okOrElse<E>(fn: () => E): OkResult<T, E>;
  and<U>(optionB: SomeOption<U>): SomeOption<U>;
  and<U>(optionB: NoneOption<U>): NoneOption<U>;
  andThen<U>(fn: (val: T) => SomeOption<U>): SomeOption<U>;
  andThen<U>(fn: (val: T) => NoneOption<U>): NoneOption<U>;
  or(optionB: Promise<Option<T>>): SomeOption<T>;
  or(optionB: PromiseOption<T>): SomeOption<T>;
  or(optionB: SomeOption<T>): SomeOption<T>;
  or(optionB: NoneOption<T>): SomeOption<T>;
  or(optionB: Option<T>): SomeOption<T>;
  orElse(fn: () => Promise<Option<T>>): SomeOption<T>;
  orElse(fn: () => PromiseOption<T>): SomeOption<T>;
  orElse(fn: () => SomeOption<T>): SomeOption<T>;
  orElse(fn: () => NoneOption<T>): SomeOption<T>;
  orElse(fn: () => Option<T>): SomeOption<T>;
} & Option<T>;

export function Some<T>(value: T): SomeOption<T>;
export function Some<T>(value: Promise<T>): PromiseOption<T>;

export type PromiseOption<T> = {
  expect(msg: string): Promise<T>;
  unwrap(): Promise<T>;
  unwrapOr(def: T): Promise<T>;
  unwrapOrElse(fn: () => T): Promise<T>;
  map<E>(fn: (val: T) => Promise<E>): PromiseOption<E>;
  map<E>(fn: (val: T) => E): PromiseOption<E>;
  mapOr<E>(def: E, fn: (val: T) => E): PromiseOption<E>;
  mapOrElse<E>(def: () => E, fn: (val: T) => E): PromiseOption<E>;
  okOr<E>(error: E): PromiseResult<T, E>;
  okOrElse<E>(fn: () => E): PromiseResult<T, E>;
  iter(): AsyncIterable<T>;
  and<U>(optionB: Promise<Option<U>>): PromiseOption<U>;
  and<U>(optionB: PromiseOption<U>): PromiseOption<U>;
  and<U>(optionB: SomeOption<U>): PromiseOption<U>;
  and<U>(optionB: NoneOption<U>): PromiseOption<U>;
  and<U>(optionB: Option<U>): PromiseOption<U>;
  andThen<U>(fn: (val: T) => Promise<Option<U>>): PromiseOption<U>;
  andThen<U>(fn: (val: T) => PromiseOption<U>): PromiseOption<U>;
  andThen<U>(fn: (val: T) => SomeOption<U>): PromiseOption<U>;
  andThen<U>(fn: (val: T) => NoneOption<U>): PromiseOption<U>;
  andThen<U>(fn: (val: T) => Option<U>): PromiseOption<U>;
  or(optionB: Promise<Option<T>>): PromiseOption<T>;
  or(optionB: PromiseOption<T>): PromiseOption<T>;
  or(optionB: SomeOption<T>): PromiseOption<T>;
  or(optionB: NoneOption<T>): PromiseOption<T>;
  or(optionB: Option<T>): PromiseOption<T>;
  orElse(fn: () => Promise<Option<T>>): PromiseOption<T>;
  orElse(fn: () => PromiseOption<T>): PromiseOption<T>;
  orElse(fn: () => SomeOption<T>): PromiseOption<T>;
  orElse(fn: () => NoneOption<T>): PromiseOption<T>;
  orElse(fn: () => Option<T>): PromiseOption<T>;
  match<U>(opts: { some: (val: T) => Promise<U>, none: () => Promise<U> }): Promise<U>;
  match<U>(opts: { some: (val: T) => U, none: () => U }): Promise<U>;
} & PromiseLike<Option<T>>;


export function ToOption<T>(value: null): NoneOption<T>;
export function ToOption<T>(value: undefined): NoneOption<T>;
export function ToOption<T>(value: Promise<SomeOption<T>>): PromiseOption<T>;
export function ToOption<T>(value: Promise<NoneOption<T>>): PromiseOption<T>;
export function ToOption<T>(value: Promise<Option<T>>): PromiseOption<T>;
export function ToOption<T>(value: SomeOption<T>): SomeOption<T>;
export function ToOption<T>(value: NoneOption<T>): NoneOption<T>;
export function ToOption<T>(value: Option<T>): Option<T>;
export function ToOption<T>(value: T): SomeOption<T>;

export type Result<T, E> = {
  isOk(): boolean;
  isErr(): boolean;
  ok(): Option<T>;
  err(): Option<E>;
  map<U>(fn: (val: T) => Promise<U>): PromiseResult<U, E>;
  map<U>(fn: (val: T) => U): Result<U, E>;
  mapErr<F>(fn: (err: E) => Promise<F>): Result<T, F>;
  mapErr<F>(fn: (err: E) => F): Result<T, F>;
  iter(): Iterable<T>;
  and<U>(res: Promise<Result<U, E>>): PromiseResult<U, E>;
  and<U>(res: PromiseResult<U, E>): PromiseResult<U, E>;
  and<U>(res: Result<U, E>): Result<U, E>;
  andThen<U>(fn: (val: T) => Promise<Result<U, E>>): PromiseResult<U, E>;
  andThen<U>(fn: (val: T) => PromiseResult<U, E>): PromiseResult<U, E>;
  andThen<U>(fn: (val: T) => Result<U, E>): Result<U, E>;
  or<F>(res: Promise<Result<T, F>>): PromiseResult<T, F>;
  or<F>(res: PromiseResult<T, F>): PromiseResult<T, F>;
  or<F>(res: Result<T, F>): Result<T, F>;
  orElse<F>(fn: (err: E) => Promise<Result<T, F>>): PromiseResult<T, F>;
  orElse<F>(fn: (err: E) => PromiseResult<T, F>): PromiseResult<T, F>;
  orElse<F>(fn: (err: E) => Result<T, F>): Result<T, F>;
  unwrap(): T | never;
  unwrapErr(): E | never;
  unwrapOr(optionB: T): T;
  unwrapOrElse(fn: (err: E) => Promise<T>): T;
  unwrapOrElse(fn: (err: E) => T): T;
  expect(msg: string): T | never;
  expectErr(msg: string): E | never;
  match<U>(opts: { ok: (val: T) => U, err: (err: E) => U }): U;
  valueOf(): string;
};

export type OkResult<T, E = never> = {
  isOk(): true;
  isErr(): false;
  ok(): SomeOption<T>;
  err(): NoneOption<E>;
  map<U>(fn: (val: T) => U): OkResult<U, E>;
  mapErr<F>(fn: (err: E) => Promise<F>): OkResult<T, F>;
  mapErr<F>(fn: (err: E) => F): OkResult<T, F>;
  and<U>(res: OkResult<U, E>): OkResult<U, E>;
  and<U>(res: ErrResult<U, E>): ErrResult<U, E>;
  andThen<U>(fn: (val: T) => OkResult<U, E>): OkResult<U, E>;
  andThen<U>(fn: (val: T) => ErrResult<U, E>): ErrResult<U, E>;
  or<F>(res: Promise<Result<T, F>>): OkResult<T, F>;
  or<F>(res: PromiseResult<T, F>): OkResult<T, F>;
  or<F>(res: OkResult<T, F>): OkResult<T, F>;
  or<F>(res: ErrResult<T, F>): OkResult<T, F>;
  or<F>(res: Result<T, F>): OkResult<T, F>;
  orElse<F>(fn: (err: E) => Promise<Result<T, F>>): OkResult<T, F>;
  orElse<F>(fn: (err: E) => PromiseResult<T, F>): OkResult<T, F>;
  orElse<F>(fn: (err: E) => OkResult<T, F>): OkResult<T, F>;
  orElse<F>(fn: (err: E) => ErrResult<T, F>): OkResult<T, F>;
  orElse<F>(fn: (err: E) => Result<T, F>): OkResult<T, F>;
  unwrap(): T;
  unwrapErr(): never;
  expect(msg: string): T;
  expectErr(msg: string): never;
} & Result<T, E>;

export type ErrResult<T, E> = {
  isOk(): false;
  isErr(): true;
  ok(): NoneOption<T>;
  err(): SomeOption<E>;
  map<U>(fn: (val: T) => Promise<U>): ErrResult<U, E>;
  map<U>(fn: (val: T) => U): ErrResult<U, E>;
  mapErr<F>(fn: (err: E) => F): ErrResult<T, F>;
  and<U>(res: Promise<Result<U, E>>): ErrResult<U, E>;
  and<U>(res: PromiseResult<U, E>): ErrResult<U, E>;
  and<U>(res: OkResult<U, E>): ErrResult<U, E>;
  and<U>(res: ErrResult<U, E>): ErrResult<U, E>;
  and<U>(res: Result<U, E>): ErrResult<U, E>;
  andThen<U>(fn: (val: T) => Promise<Result<U, E>>): ErrResult<U, E>;
  andThen<U>(fn: (val: T) => PromiseResult<U, E>): ErrResult<U, E>;
  andThen<U>(fn: (val: T) => OkResult<U, E>): ErrResult<U, E>;
  andThen<U>(fn: (val: T) => ErrResult<U, E>): ErrResult<U, E>;
  andThen<U>(fn: (val: T) => Result<U, E>): ErrResult<U, E>;
  or(res: OkResult<T, E>): OkResult<T, E>;
  or(res: ErrResult<T, E>): ErrResult<T, E>;
  orElse(fn: (err: E) => OkResult<T, E>): OkResult<T, E>;
  orElse(fn: (err: E) => ErrResult<T, E>): ErrResult<T, E>;
  unwrap(): never;
  unwrapErr(): E;
  expect(msg: string): never;
  expectErr(msg: string): E;
  valueOf(): string;
} & Result<T, E>;

export type PromiseResult<T, E> = {
  ok(): PromiseOption<T>;
  err(): PromiseOption<E>;
  map<U>(fn: (val: T) => Promise<U>): PromiseResult<U, E>;
  map<U>(fn: (val: T) => U): PromiseResult<U, E>;
  mapErr<F>(fn: (err: E) => Promise<F>): PromiseResult<T, F>;
  mapErr<F>(fn: (err: E) => F): PromiseResult<T, F>;
  iter(): AsyncIterable<T>;
  and<U>(res: Promise<Result<U, E>>): PromiseResult<U, E>;
  and<U>(res: PromiseResult<U, E>): PromiseResult<U, E>;
  and<U>(res: Result<U, E>): PromiseResult<U, E>;
  andThen<U>(fn: (val: T) => Promise<Result<U, E>>): ErrResult<U, E>;
  andThen<U>(fn: (val: T) => PromiseResult<U, E>): ErrResult<U, E>;
  andThen<U>(fn: (val: T) => Result<U, E>): ErrResult<U, E>;
  or(res: Promise<Result<T, E>>): PromiseResult<T, E>;
  or(res: PromiseResult<T, E>): PromiseResult<T, E>;
  or(res: Result<T, E>): PromiseResult<T, E>;
  orElse(fn: (err: E) => Promise<Result<T, E>>): PromiseResult<T, E>;
  orElse(fn: (err: E) => PromiseResult<T, E>): PromiseResult<T, E>;
  orElse(fn: (err: E) => Result<T, E>): PromiseResult<T, E>;
  unwrap(): Promise<T>;
  unwrapErr(): Promise<E>;
  unwrapOr(optionB: T): Promise<T>;
  unwrapOrElse(fn: (err: E) => Promise<T>): Promise<T>;
  unwrapOrElse(fn: (err: E) => T): Promise<T>;
  expect(msg: string): Promise<T>;
  expectErr(msg: string): Promise<E>;
  match<U>(opts: { ok: (val: T) => Promise<U>, err: (err: E) => Promise<U> }): Promise<U>;
  match<U>(opts: { ok: (val: T) => U, err: (err: E) => U }): Promise<U>;
} & PromiseLike<Result<T, E>>;

export function Ok<T>(value: Promise<T>): PromiseResult<T, never>;
export function Ok<T>(value: T): OkResult<T, never>;
export function Err<E>(error: Promise<E>): PromiseResult<never, E>;
export function Err<E>(error: E): ErrResult<never, E>;
export function FlattenResult<T, E>(promise: Promise<Result<T, E>>): PromiseResult<T, E>;
export function FlattenResult<T, E>(promise: PromiseResult<T, E>): PromiseResult<T, E>;
export function FlattenResult<T, E>(promise: OkResult<T, E>): OkResult<T, E>;
export function FlattenResult<T, E>(promise: ErrResult<T, E>): ErrResult<T, E>;
export function FlattenResult<T, E>(promise: Result<T, E>): Result<T, E>;
