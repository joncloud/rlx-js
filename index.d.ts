export type NoneOption<T> = {
  isSome(): false;
  isNone(): true;
  expect(msg: string): never;
  unwrap(): never;
  unwrapOr<U extends T>(def: U): U;
  unwrapOrElse<U extends T>(fn: () => U): U;
  map<U>(fn: (val: T) => U): NoneOption<U>;
  mapOr<U>(def: U, fn: (val: T) => U): NoneOption<U>;
  mapOrElse<U>(def: () => U, fn: (val: T) => U): NoneOption<U>;
  okOr<E>(error: Promise<E>): PromiseResult<T, E>;
  okOr<E>(error: E): ErrResult<T, E>;
  okOrElse<E>(fn: () => Promise<E>): PromiseResult<T, E>;
  okOrElse<E>(fn: () => E): ErrResult<T, E>;
  iter(): Iterable<T>;
  and<O extends PromiseOption<T>>(optionB: O): NoneOption<T>;
  and<O extends Option<T>>(optionB: O): NoneOption<T>;
  andThen<O extends PromiseOption<T>>(fn: () => O): NoneOption<T>;
  andThen<O extends Option<T>>(fn: () => O): NoneOption<T>;
  or<O extends PromiseOption<T>>(optionB: O): O;
  or<O extends Option<T>>(optionB: O): O;
  orElse<O extends PromiseOption<T>>(fn: () => O): O;
  orElse<O extends Option<T>>(fn: () => O): O;
  valueOf(): 'none{}';
};

export function None<T>(): NoneOption<T>;

export type SomeOption<T> = {
  isSome(): true;
  isNone(): false;
  expect(msg: string): T;
  unwrap(): T;
  unwrapOr(def: T): T;
  unwrapOrElse(fn: () => T): T;
  map<U>(fn: (val: T) => Promise<U>): PromiseOption<U>;
  map<U>(fn: (val: T) => U): SomeOption<U>;
  mapOr<U>(def: Promise<U>, fn: (val: T) => Promise<U>): PromiseOption<U>;
  mapOr<U>(def: U, fn: (val: T) => U): SomeOption<U>;
  mapOrElse<U>(def: () => Promise<U>, fn: (val: T) => U): PromiseOption<U>;
  mapOrElse<U>(def: () => U, fn: (val: T) => U): SomeOption<U>;
  okOr<E>(error: Promise<E>): OkResult<T, E>;
  okOr<E>(error: E): OkResult<T, E>;
  okOrElse<E>(fn: () => Promise<E>): OkResult<T, E>;
  okOrElse<E>(fn: () => E): OkResult<T, E>;
  iter(): Iterable<T>;
  and<O extends PromiseOption<T>>(optionB: Promise<O>): O;
  and<O extends Option<T>>(optionB: O): O;
  andThen<O extends PromiseOption<T>>(fn: () => Promise<O>): O;
  andThen<O extends Option<T>>(fn: () => O): O;
  or<O extends PromiseOption<T>>(optionB: O): SomeOption<T>;
  or<O extends Option<T>>(optionB: O): SomeOption<T>;
  orElse<O extends PromiseOption<T>>(fn: () => O): SomeOption<T>;
  orElse<O extends Option<T>>(fn: () => O): SomeOption<T>;
  valueOf(): string;
};

export function Some<T>(value: T): SomeOption<T>;
export function Some<T>(value: Promise<T>): PromiseOption<T>;

export type Option<T> = NoneOption<T> | SomeOption<T>;

export type PromiseOption<T> = {
  expect(msg: string): Promise<T>;
  unwrap(): Promise<T>;
  unwrapOr(def: T): Promise<T>;
  unwrapOrElse(fn: () => T): Promise<T>;
  map<E>(fn: (val: T) => Promise<E>): PromiseOption<E>;
  map<E>(fn: (val: T) => E): PromiseOption<E>;
  mapOr<E>(def: E, fn: (val: T) => E): PromiseOption<E>;
  mapOrElse<E>(def: () => E, fn: (val: T) => E): PromiseOption<E>;
  okOr<E>(error: E): PromiseResult<T, E>;
  okOrElse<E>(fn: () => E): PromiseResult<T, E>;
  iter(): AsyncIterable<T>;
  and<O extends Option<T>>(optionB: O): PromiseOption<T>;
  and<O extends PromiseOption<T>>(optionB: O): PromiseOption<T>;
  andThen<O extends Option<T>>(fn: () => O): PromiseOption<T>;
  or<O extends Option<T>>(optionB: O): PromiseOption<T>;
  orElse<O extends Option<T>>(fn: () => O): PromiseOption<T>;
} & PromiseLike<Option<T>>;

export function ToOption<T>(value: null): NoneOption<T>;
export function ToOption<T>(value: undefined): NoneOption<T>;
export function ToOption<T>(value: Promise<SomeOption<T>>): PromiseOption<T>;
export function ToOption<T>(value: Promise<NoneOption<T>>): PromiseOption<T>;
export function ToOption<T>(value: Promise<Option<T>>): PromiseOption<T>;
export function ToOption<T>(value: SomeOption<T>): SomeOption<T>;
export function ToOption<T>(value: NoneOption<T>): NoneOption<T>;
export function ToOption<T>(value: Option<T>): Option<T>;
export function ToOption<T>(value: T): SomeOption<T>;

export type OkResult<T, E = never> = {
  isOk(): true;
  isErr(): false;
  ok(): SomeOption<T>;
  err(): NoneOption<E>;
  map<U>(fn: (val: T) => Promise<U>): PromiseResult<U, E>;
  map<U>(fn: (val: T) => U): OkResult<U, E>;
  mapErr<F>(fn: (err: E) => Promise<F>): OkResult<T, F>;
  mapErr<F>(fn: (err: E) => F): OkResult<T, F>;
  iter(): Iterable<T>;
  and<U extends T>(res: PromiseResult<U, E>): PromiseResult<U, E>;
  and<U extends T>(res: Result<U, E>): OkResult<U, E>;
  and<U extends T>(res: Result<U, E>): ErrResult<U, E>;
  and<U extends T>(res: Result<U, E>): Result<U, E>;
  andThen<U extends T>(fn: (val: T) => Promise<Result<U, E>>): PromiseResult<U, E>;
  andThen<U extends T>(fn: (val: T) => OkResult<U, E>): OkResult<U, E>;
  andThen<U extends T>(fn: (val: T) => ErrResult<U, E>): ErrResult<U, E>;
  andThen<U extends T>(fn: (val: T) => Result<U, E>): Result<U, E>;
  or<U extends T>(res: PromiseResult<U, E>): OkResult<U, E>;
  or<U extends T>(res: Result<U, E>): OkResult<U, E>;
  orElse<U extends T>(fn: (err: E) => PromiseResult<U, E>): OkResult<U, E>;
  orElse<U extends T>(fn: (err: E) => Result<U, E>): OkResult<U, E>;
  unwrap(): T;
  unwrapErr(): never;
  unwrapOr<U extends T>(optionB: U): T;
  unwrapOrElse<U extends T>(fn: (err: E) => Promise<U>): U;
  unwrapOrElse<U extends T>(fn: (err: E) => U): U;
  expect(msg: string): T;
  expectErr(msg: string): never;
  valueOf(): string;
};

export type ErrResult<T, E> = {
  isOk(): false;
  isErr(): true;
  ok(): NoneOption<T>;
  err(): SomeOption<E>;
  map<U>(fn: (val: T) => Promise<U>): ErrResult<U, E>;
  map<U>(fn: (val: T) => U): ErrResult<U, E>;
  mapErr<F>(fn: (err: E) => Promise<F>): PromiseResult<T, F>;
  mapErr<F>(fn: (err: E) => F): ErrResult<T, F>;
  iter(): Iterable<T>;
  and<U extends T>(res: PromiseResult<U, E>): ErrResult<U, E>;
  and<U extends T>(res: Result<U, E>): ErrResult<U, E>;
  andThen<U extends T>(fn: (val: T) => Promise<U>): ErrResult<U, E>;
  andThen<U extends T>(fn: (val: T) => U): ErrResult<U, E>;
  or<U extends T>(res: PromiseResult<U, E>): PromiseResult<U, E>;
  or<U extends T>(res: OkResult<U, E>): OkResult<U, E>;
  or<U extends T>(res: ErrResult<U, E>): ErrResult<U, E>;
  or<U extends T>(res: Result<U, E>): Result<U, E>;
  orElse<U extends T>(fn: (err: E) => PromiseResult<U, E>): PromiseResult<U, E>;
  orElse<U extends T>(fn: (err: E) => OkResult<U, E>): OkResult<U, E>;
  orElse<U extends T>(fn: (err: E) => ErrResult<U, E>): ErrResult<U, E>;
  orElse<U extends T>(fn: (err: E) => Result<U, E>): Result<U, E>;
  unwrap(): never;
  unwrapErr(): E;
  unwrapOr<U extends T>(optionB: U): U;
  unwrapOrElse<U extends T>(fn: (err: E) => Promise<U>): Promise<U>;
  unwrapOrElse<U extends T>(fn: (err: E) => U): U;
  expect(msg: string): never;
  expectErr(msg: string): E;
  valueOf(): string;
};
export type Result<T, E> = OkResult<T, E> | ErrResult<T, E>;

export type PromiseResult<T, E> = {
  ok(): PromiseOption<T>;
  err(): PromiseOption<E>;
  map<U>(fn: (val: T) => Promise<U>): PromiseResult<U, E>;
  map<U>(fn: (val: T) => U): PromiseResult<U, E>;
  mapErr<F>(fn: (err: E) => Promise<F>): PromiseResult<T, F>;
  mapErr<F>(fn: (err: E) => F): PromiseResult<T, F>;
  iter(): AsyncIterable<T>;
  and<U extends T>(res: PromiseResult<U, E>): PromiseResult<U, E>;
  and<U extends T>(res: Result<U, E>): PromiseResult<U, E>;
  andThen<U extends T>(fn: (val: T) => Promise<U>): ErrResult<U, E>;
  andThen<U extends T>(fn: (val: T) => U): ErrResult<U, E>;
  or<U extends T>(res: PromiseResult<U, E>): PromiseResult<U, E>;
  or<U extends T>(res: Result<U, E>): PromiseResult<U, E>;
  orElse<U extends T>(fn: (err: E) => PromiseResult<U, E>): PromiseResult<U, E>;
  orElse<U extends T>(fn: (err: E) => Result<U, E>): PromiseResult<U, E>;
  unwrap(): Promise<T>;
  unwrapErr(): Promise<E>;
  unwrapOr<U extends T>(optionB: U): Promise<T>;
  unwrapOrElse<U extends T>(fn: (err: E) => Promise<U>): Promise<T>;
  unwrapOrElse<U extends T>(fn: (err: E) => U): Promise<T>;
  expect(msg: string): Promise<T>;
  expectErr(msg: string): Promise<E>;
} & PromiseLike<Result<T, E>>;

export function Ok<T, E = never>(value: Promise<T>): PromiseResult<T, E>;
export function Ok<T, E = never>(value: T): OkResult<T, E>;
export function Err<E, T = never>(error: Promise<E>): PromiseResult<T, E>;
export function Err<E, T = never>(error: E): ErrResult<T, E>;
